Skip to content
Chat history





You said:
GetStack is vibe coded in Replit.

Help me make a prompt to create a secure and safe login system.
There’s a free tool available with less options, but there’s also a dashboard version (pin websites, add premium features etc).  Eventually login will have paid tiers.

I want to have a safe, secure login via email or Google or GitHub that allows users to access the dashboard.  If they are not logged in, they should have no access to the dashboard.  
ChatGPT said:
Here’s a copy/paste prompt you can drop into Replit (or whatever agent you’re using) to generate a secure auth + protected dashboard setup with email + Google + GitHub, designed so logged-out users cannot access anything dashboard-related, and leaving a clean path to paid tiers later.

You are a senior security-focused full-stack engineer. Help me implement a secure authentication system for a web app called GetStack.

GOAL
- Users can sign in using:
  1) Email (magic link OR email+password — choose the safest/easiest default)
  2) Google OAuth
  3) GitHub OAuth
- After login, users can access a “Dashboard” area.
- If not logged in, users must have ZERO access to the dashboard (both UI routes AND API endpoints).
- Sessions must be secure, with best-practice cookie settings and CSRF protections where applicable.
- The system should support future paid tiers (Free vs Premium) and feature gating.

CONSTRAINTS
- This is being built in Replit. Assume environment variables are available for secrets.
- Minimize custom cryptography. Prefer well-supported libraries/framework patterns.
- Don’t store OAuth tokens in localStorage. Prefer httpOnly secure cookies.
- Provide a simple local/dev mode and a production mode.

PLEASE ASK ME (only if required)
- What framework am I using (Next.js / Express / Fastify / Remix / etc.)?
- What database I’m using (Postgres / SQLite / Mongo / etc.)?
If not provided, choose a sensible default stack and proceed.

DELIVERABLES (be concrete)
1) Architecture decision: choose an auth approach (e.g., Auth.js/NextAuth, Lucia, Clerk, Supabase Auth, Firebase Auth, or Passport) and explain why it’s secure and fits Replit.
2) Database schema for users + sessions + accounts (OAuth) + roles/tier:
   - users: id, email, name, image, created_at
   - accounts: provider, provider_account_id, user_id
   - sessions: id, user_id, expires_at, session_token (or equivalent)
   - subscriptions/tiers: user_id, tier (“free” | “premium”), status, current_period_end
3) Implemented routes:
   - /login (UI)
   - /logout
   - /dashboard (protected)
   - /api/* protected endpoints (example: /api/pins)
4) Security requirements checklist implemented:
   - Password hashing (if passwords are used): Argon2id or bcrypt with good parameters
   - Rate limiting / brute force protection for login endpoints
   - Email verification (if email+password is used)
   - Secure cookies: httpOnly, secure, sameSite=Lax or Strict, proper expiry
   - CSRF protection if using cookie sessions + state-changing POSTs
   - OAuth: state + PKCE, proper callback URL handling
   - Prevent open redirects
   - Session fixation prevention and session rotation on login
5) Access control:
   - Middleware/guard that blocks non-authenticated users from /dashboard and all /api routes under /api/dashboard/*
   - Return 401/403 from APIs instead of redirecting
6) Future-proofing for paid tiers:
   - Add feature flags / tier checks in code (e.g., “pin websites” free limit vs premium)
   - A function like `requireTier("premium")` and an example usage
7) Give me exact environment variables I need to set (GOOGLE_CLIENT_ID, etc.) and where to put them in Replit.
8) Provide the full code changes as files/patches, plus step-by-step “how to run” instructions.

TESTING
- Include a short test plan:
  - Logged out users can’t load /dashboard (server-side) and can’t call protected APIs
  - Logged in users can access
  - OAuth flow works for Google + GitHub
  - Session cookie flags correct in production
  - Rate limiting triggers after repeated login attempts

IMPORTANT
- Treat this as production-grade security. If you must compromise due to constraints, clearly label the compromise and provide a safer alternative.
Tiny tweak if you already know your stack
If GetStack is, say, Next.js, add this line near the top:

“Stack: Next.js (App Router), Postgres (or SQLite), Prisma.”

If it’s Express, add:

“Stack: Node + Express, Postgres (or SQLite), Prisma.”

One key security note (so you don’t get fooled by “hidden UI”)
Make sure the agent implements both:

Route protection (middleware / server-side redirect)

API protection (401/403 on protected endpoints)

Because hiding the dashboard link in the UI does nothing if the endpoint is still reachable.

If you tell me your framework + DB (even in one line), I can tighten the prompt further so it generates the exact libraries and file layout you’ll actually use in Replit.

You said:
We’re using react and tailwinds ui.  Not sure about db. - may not have been implemented yet 
ChatGPT said:
Cool — here’s an updated vibe-coding prompt that assumes React + Tailwind UI and no DB yet, and guides the agent to pick a safe default (SQLite + Prisma) or run DB-less temporarily (but still secure-ish) while you build.

You are a senior security-focused full-stack engineer. I’m building GetStack in Replit using React + Tailwind UI. I’m not sure if a database has been implemented yet.

GOAL
- Implement production-grade authentication with:
  1) Email login (choose the safest/easiest: magic link preferred; avoid passwords unless necessary)
  2) Google OAuth
  3) GitHub OAuth
- After login, users can access a protected “Dashboard”.
- If not logged in, users must have ZERO access to the dashboard:
  - cannot load dashboard routes (server-enforced, not just UI hiding)
  - cannot call dashboard APIs (must return 401/403)
- Sessions must use secure, httpOnly cookies (NOT localStorage).
- Must be future-proof for paid tiers (Free vs Premium) and feature gating.

ASSUME / DECIDE
- Because plain React is frontend-only, we need a backend (Node) for OAuth, sessions, and protected APIs.
- If no backend exists yet, create one:
  - Node + Express (or Fastify) as an API server
  - Use a proven auth library/pattern
- If no database exists yet, choose a safe default that works well in Replit:
  - SQLite + Prisma as the initial DB layer (easy in Replit)
  - Include migrations and a simple schema
  - If you must do a DB-less temporary mode, clearly label it as NOT production safe and still keep secure cookies; but the primary solution must be DB-backed.

AUTH APPROACH (CHOOSE ONE AND IMPLEMENT)
Preferred: use a proven auth solution with OAuth best practices built in.
Options you may choose from (pick the best fit for React + Node):
- Lucia
- Auth.js (if appropriate)
- Passport (only if you can keep it secure and simple)
- Supabase Auth (only if it truly simplifies + stays secure)
Do NOT invent custom crypto or homebrew session systems.

SECURITY REQUIREMENTS (MUST IMPLEMENT)
- Session cookies: httpOnly, secure (in prod), sameSite=Lax (or Strict where safe), proper maxAge/expires
- CSRF protection for cookie-based sessions on state-changing requests
- OAuth security: state parameter + PKCE (where applicable), strict callback URL validation
- Rate limiting for auth endpoints (magic link request, OAuth callback, etc.)
- Prevent open redirects (only allow redirects to same-origin paths)
- Input validation on all auth endpoints
- No tokens in localStorage
- Session rotation on login and logout (invalidate old session)
- Minimal user data in session

FEATURES / PAGES
Frontend (React + Tailwind UI):
- /login page with buttons: “Continue with Google”, “Continue with GitHub”, and email login field
- /dashboard page: must be protected (if not authed, user is redirected to /login)
Backend (Node API):
- /auth/google/start + /auth/google/callback
- /auth/github/start + /auth/github/callback
- /auth/email/request-link (send magic link)
- /auth/email/callback (verify magic link, create session)
- /auth/logout
- /api/me (returns current user if logged in, else 401)
- /api/pins (example protected dashboard API)

ACCESS CONTROL
- Implement middleware/guard on backend that enforces auth for any route under:
  - /api/*
  - specifically /api/pins and any future dashboard API
- Frontend route guard must still exist, but backend enforcement is mandatory.
- APIs must return 401/403 (not HTML redirects).

DATABASE (IMPLEMENT IF NOT PRESENT)
Use Prisma + SQLite with this minimum schema:
- users: id, email (unique), name, image, email_verified, created_at
- accounts: id, user_id, provider, provider_account_id, created_at
- sessions: id, user_id, session_token_hash, expires_at, created_at
- magic_links: id, email, token_hash, expires_at, used_at
- user_tiers: user_id, tier (“free” | “premium”), status, current_period_end

PAID TIERS (FUTURE-PROOF NOW)
- Add a `requireTier("premium")` helper on the backend
- Add a `canPinMoreSites(user)` example:
  - Free: max 3 pins
  - Premium: unlimited (or higher limit)
- Put the tier check in the API, not only in the UI.

DELIVERABLES
1) Tell me what stack you detected/assumed (how React is served, whether a Node backend exists).
2) Provide full code as files/patches:
   - backend server (Express/Fastify)
   - auth setup
   - prisma schema + migration instructions
   - frontend pages and API calling pattern (fetch with credentials)
3) Provide exact Replit environment variables I must set:
   - GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET
   - GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET
   - APP_BASE_URL (e.g., https://<replit>.repl.co)
   - SESSION_SECRET (strong random)
   - EMAIL_PROVIDER creds (or a dev console logger for emails with a big warning)
4) Step-by-step run instructions
5) A short test plan (auth flows, session cookie flags, blocked access when logged out)

IMPORTANT
- Production-grade security first. If Replit constraints force compromises (e.g., email sending), label them clearly and give the safer alternative.
- Keep explanations short; prioritize working code.
Two quick “gotchas” to keep your build actually secure
A React-only app can’t securely do OAuth by itself. You need a backend (or a hosted auth provider). This prompt forces the agent to add one.

Make sure your frontend requests use fetch(..., { credentials: "include" }) so the httpOnly session cookie is actually sent.

If you tell me one more detail — is this “React” actually Next.js, Vite, or CRA? — I can tighten the prompt even more so it generates the exact file tree and scripts your Replit project already has.


mute
mute

English (US)
settings
microphone


No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.
